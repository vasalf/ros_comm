# Проект по C++

## Суть

Есть ROS. В нём есть сервисы -- метод общения между процессами. И сейчас этим методом не получается общаться внутри одного процесса -- случается deadlock или что-то похожее. Нужно это исправить.

## Идея решения

Внутри ROS нагромождена громадная куча архитектуры. Всё для жизни, всё поточно-безопасное, и прочее. В этих условиях проще спуститься на самый низ этой иерархии и действовать на собственно самом низком уровне, не забывая, впрочем, про потокобезопасность. Чтобы, во всяком случае, не переписывать специально для внутрипроцессного взаимодействия всю архитектуру специально заново.

ROS передаёт данные в конечном итоге по TCP (класс `TransportTCP`). Передавать внутри одного процесса данные по TCP по меньшей мере странно. Класс `TransportTCP` унаследован от интерфейса `Transport`. Для решения я создал класс `TransportIntraProcess`, наследованный от того же `Transport`, и некий код, поддерживающий создания именно этого типа взаимодействия при внутрипроцессном использовании сервисов.

## Где искать решение?

Я сделал честный форк репозитория `ros_comm`, он расположен вот [здесь](https://github.com/vasalf/ros_comm), мои изменения находятся в ветке `service-intra-process-communication`. Впрочем, патч от оригинальной ветки `kinetic-devel` на всякий случай лежит и в [этом репозитории](https://github.com/vasalf/ros_test_intra_process_service_communication) и называется `intra-process_service_communication.patch`.

## На чём я тестировал?

В [этом репозитории](https://github.com/vasalf/ros_test_intra_process_service_communication) лежат два моих теста -- однопоточный (`single_thread`) и многопоточный (`multiple_thread`). Собирается проект так же как и любой другой ROS-пакет, package называется `test_intra_process_service_communication`, в нём, соответственно, есть исполняемые файлы `single_thread` и `multiple_threads`. Можно также проверить, что со стороны при этом всё ещё можно обратиться к сервису, выполнив в момент, когда запущены `single_thread` или `multiple_threads`, исполняемый файл `call_from_outside` из того же package'а.